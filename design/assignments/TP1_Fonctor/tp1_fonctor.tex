\documentclass{tdlayout}
\usepackage{graphicx}

\usepackage[colorlinks=true]{hyperref}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% HEADER INFORMATIONS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\fancyhead[R]{Enseignant : J.Falcou (joel.falcou@lri.fr)\\Resp. TP : F.Laguzet (florence.laguzet@lri.fr)}
\fancyhead[L]{APP4 POO}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FOOTER INFORMATIONS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\fancyfoot[L]{POO TP1}
\fancyfoot[R]{2012-2013}
\fancyfoot[C]{\thepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\displaytitle{TP1 : La méthode LISKOV \\et le Design Pattern Fonctor}

%% Original version by P.Esterie

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{ Utilisation de la méthode LISKOV } 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ----------------------------------------------------------------------------- %
\section{Préambule}
% ----------------------------------------------------------------------------- %
Dans cette partie nous allons aborder : 
\begin{itemize}
\item Les namespaces
\item Le principe d'ADL (\emph{Argument-Dependent name Lookup}) 
\item Le polymorphisme dynamique et statique
\end{itemize}
\vspace{0.5cm}
Dans un premier temps vous allez procéder à l'\textbf{installation des bibliothèques BOOST} disponibles à l'adresse suivante : \url{http://www.boost.org/users/download/}.

% ----------------------------------------------------------------------------- %
\section{Premiers pas}
% ----------------------------------------------------------------------------- %
L'écriture d'un code, quel qu'il soit, doit être pensée pour sa réutilisation et sa maintenance. 
Un code existant doit être facilement extensible et l'ajout de nouvelles fonctionnalités ne doit pas induire une modification du code existant. 
Pour ce faire, le polymorphisme nous permet de réutiliser du code existant sur différents types. 
Au sein de C++, le mécanisme d'héritage nous permet de réaliser du polymorphisme de classe.\\
Pour traiter les problèmes listés dans le préambule, nous allons travailler avec les formes géométriques, nous les nommerons \emph{shapes}. 
Gr\^ace au propriétés mathématiques des \emph{shapes} nous allons illustrer et démontrer comment réaliser de l'héritage proprement.      

% ----------------------------------------------------------------------------- %
\section{Implémentation}
% ----------------------------------------------------------------------------- %
\subsection{La classe de base}
Notre classe de base représentera le \emph{shape} rectangle, elle sera nommée {\tt rectangle}. Elle respectera la forme canonique de Coplien et proposera des accesseurs et des mutateurs. De plus, elle devra proposer une fonction membre de calcul de l'aire du rectangle.
\vspace{0.5cm}
\begin{itemize}
	\item \textbf{Comment doit ont déclarer les fonctions membres pour que la classe de base soit dérivable ?}
	\item \textbf{Quelles fonctions membres de notre classe doivent respecter cette déclaration ?}
	\item \textbf{Implémentez cette classe !}
\end{itemize}

\subsection{La classe dérivée}
\paragraph{Polymorphisme dynamique}\hfill \newline
La classe dérivée de {\tt rectangle} sera la classe {\tt square} (carré) qui héritera dynamiquement de la classe {\tt rectangle}.
\vspace{0.5cm}
\begin{itemize}
	\item \textbf{Quelles fonctions membres doivent être redifinies dans notre nouvelle classe ?}
	\item \textbf{Quelles sont les limitations d'un tel héritage ?}
	\item \textbf{Implémentez cette classe !}
\end{itemize}

\subsection{Asserts et exceptions}
Lors de la construction de la classe dérivée {\tt square} et durant l'appel de ses fonctions membres une précondition et une postcondition doit être toujours vrai.
\begin{itemize}
	\item \textbf{Quelles sont ces pré/postconditions ?}
\end{itemize}
Pour gérer cette programmation par contrat, des asserts sont mises en place pour les précondition et des exceptions sont envoyées si la/les postconditions ne sont pas vérifiées.
\begin{itemize}
	\item \textbf{Durcissez vos classes en respectant ce principe.}
\end{itemize}

\subsection{Namespace, ADL et Swap}
Les \emph{namespaces} sont des espaces de nommage dans lesquels classes et fonctions vivent. En effet, si deux fonctions sont déclarées avec le m\^eme nom, un conflit appara\^it. Les \emph{namespaces} permettent de qualifier ces fonctions (ou classe) et le compilateur sera capable de distinguer les deux déclarations. Lors de l'appel de cette fonction non qualifiée, l'\emph{Argument-Dependent name Lookup} (ADL) va se charger de trouver le bon appel de fonction parmis les namespaces qualifiant les arguments de la fonction. Attention, l'ADL ne survient que lorque la phase classique de \emph{lookup} échoue.
\vspace{0.5cm}
\begin{itemize}
	\item \textbf{Implémentez la surcharge de l'opérateur {\tt <<} pour afficher un rectangle ou un carré dans la console. Illustrer l'ADL réalisé lors de l'appel de cet opérateur.}     
	\item \textbf{Implémentez une fonction libre de {\tt swap} sur les rectangles/carrés en utilisant Boost SWAP.}
	\item \textbf{Expliquez comment l'ADL est utilisé au sein de Boost SWAP.} 
\end{itemize}

\subsection{LSP : Liskov Substitution Principle}
Le LSP est un principe de programmation, son énoncé est le suivant :
\begin{center}
``Si un objet \emph{x} de type {\tt T} est attendu alors on doit pouvoir passer tout objet \emph{y} de type {\tt U}, {\tt U} dérivant de {\tt T}.''
\end{center}
Dans notre exemple, le LSP s'exprime de la manière suivante : si une fonction prend en argument un {\tt rectangle} on doit pouvoir passer un {\tt carré} à cette même fonction. Pour vérifier le LSP, nous allons implémenter la fonction {\tt test\_area}. 
Cette fonction prendra un {\tt rectangle} en argument, génèrera deux nombres entiers aléatoires et appelera la fonction membre {\tt area} sur son argument. Dans le corps de la fonction, il faudra vérifier que l'aire renvoyée par la fonction membre {\tt area} est bien égale à l'aire attendue. Si ce n'est pas le cas une exception sera envoyée.
\vspace{0.5cm}
\begin{itemize}
	\item \textbf{Codez cette fonction.}
	\item \textbf{Appelez cette fonction avec un {\tt carré} en paramètre. Expliquez pourquoi le LSP n'est pas respecté.}
\end{itemize}

\section{Bonus}

\subsection{Héritage}
\vspace{0.5cm}
\begin{itemize}
\item \textbf{Proposez un autre arbre d'héritage permettant de respecter le LSP.}
\end{itemize}

\subsection{Polymorphisme statique}
Le polymorphisme dynamique trouve sa limitation lorsque le code à l'intérieur de ces fonctions est court et/ou lorsque ces fonctions sont appelées souvents. Lors d'un appel de fonction classique, le compilateur résoud cet appel et génére un saut directement à l'adresse de cette fonction. Dans le cas des fonctions virtuelles, le compilateur ne peut pas savoir quel saut réaliser pour tomber dans le bon code de la fonction car le polymorphisme dynamique induit une resolution de l'appel de la fonction au runtime (fonction virtuelle). Cet résolution dynamique utilise une table des fonctions virtuelles. A chaque appel d'une fonction virtuelle, il faut alors aller chercher l'adresse de la fonction correspondante dans la table ce qui a un co\^ut. Pour éviter ce surco\^ut, le polymorphisme statique permet de réaliser cette résolution à la compilation.       
\vspace{0.5cm}
\begin{itemize}
\item \textbf{Réimplémentez le nouvel arbre d'héritage en utilisant le polymorphisme statique.}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{ Les \textit{Fonctor} et le calcul d'intégrales }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ----------------------------------------------------------------------------- %
\section{Implémentation du calcul de l'intégrale}
% ----------------------------------------------------------------------------- %
Nous allons implémenter le calcul de l'intégrale pour une fonction $f$ choisie.
Pour cela, nous allons avoir plusieurs manières concernant l'implémentation du calcul de la fonction $f$ : en tant que pointeur de fonction, d'objet contenant une méthode et enfin à l'aide d'un \textit{Fonctor}.\\
Vous allez donc être amenés à coder 3 fonctions différentes :
\begin{description}
\item[compute\_ptr] Fonction prenant en argument un pointeur de fonction et retournant un double
\item[compute\_class] Fonction prenant en argument un objet et retournant un double
\item[compute\_fonc] Fonction prenant en argument un \textit{Fonctor} et retournant un double 
\end{description}
\hfill \\
Vos fonctions auront donc comme prototype : \\ 
\textbf{double} \texttt{compute\_X( < fonction $f$ >, \textbf{double} X, \textbf{double} $\delta_x$)}. \\
L'intervalle sur laquelle nous allons calculer l'intégrale sera $[X-\delta_x, X+\delta_x]$.\\
La fonction $f$, quant à elle, est définie comme prenant en paramètre un double et renvoyant un double.\\
Que remarquez-vous concernant les 3 manières de passer $f$ en paramètre?

% ----------------------------------------------------------------------------- %
\section{Temps d'exécution}
% ----------------------------------------------------------------------------- %
Ensuite, vous allez calculer le temps d'exécution pour chacune des trois méthodes (pointeur, objet et \textit{Fonctor}).
Pour cela, vous utiliserez la fonction \texttt{gettimeofday} définie dans \texttt{\#include <sys/time.h>}.\\
Pour son utilisation, se reporter au manuel (\texttt{man gettimeofday}).\\
Que remarquez-vous concernant les temps d'exécution? 

% ----------------------------------------------------------------------------- %
\section{ Rappel : Formule de l'intégration numérique }
% ----------------------------------------------------------------------------- %
Vous trouverez à l'adresse suivante un rappel concernant le calcul d'intégrales par la méthode des rectangles :
\textit{http://homeomath.imingo.net/methrect.htm}.\\
Vous pouvez très bien utiliser une autre méthode (trapèze, Simpson, ...).
\vspace{1cm}

\renewcommand{\arraystretch}{2}
\begin{tabular}{ >{\raggedright}m{8cm} >{\raggedright}m{8cm}}
 Soit f la fonction à intégrer et $a$ $b$ les bornes. 
On a alors $ I(f)=(b-a) f(\xi) $ avec $f$ la fonction pour laquelle nous voulons calculer l'intégrale. 
& \includegraphics[width=5cm]{pic/methode_rectangles.png}
\tabularnewline 
&	\begin{tiny}Source : Wikipedia\end{tiny}\\
\end{tabular}


\end{document}